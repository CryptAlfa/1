/*
 * Copyright (c) 2017, Jeff Hlywa (jhlywa@gmail.com)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 *----------------------------------------------------------------------------*/
/* minified license below  */
/* @license
 * Copyright (c) 2017, Jeff Hlywa (jhlywa@gmail.com)
 * Released under the BSD license
 * https://github.com/jhlywa/chess.js/blob/master/LICENSE
 */
var Chess=function(r){function e(r){void 0===r&&(r=!1),tr=new Array(128),or={w:q,b:q},ir=k,fr={w:0,b:0},ur=q,lr=0,ar=1,sr=[],pr=[],//Added in sandy98 fork.
r||(cr={}),u(i())}function n(){t(B)}function t(r,n){void 0===n&&(n=!1);var t=r.split(/\s+/),f=t[0],l=0;if(!o(r).valid)return!1;e(n);for(var s=0;s<f.length;s++){var p=f.charAt(s);if("/"===p)l+=8;else if(function(r){return-1!=="0123456789".indexOf(r)}(p))l+=parseInt(p,10);else{var c=p<"a"?k:O;a({type:p.toLowerCase(),color:c},I(l)),l++}}//Added in sandy98 fork
return ir=t[1],t[2].indexOf("K")>-1&&(fr.w|=J.KSIDE_CASTLE),t[2].indexOf("Q")>-1&&(fr.w|=J.QSIDE_CASTLE),t[2].indexOf("k")>-1&&(fr.b|=J.KSIDE_CASTLE),t[2].indexOf("q")>-1&&(fr.b|=J.QSIDE_CASTLE),ur="-"===t[3]?q:er[t[3]],lr=parseInt(t[4],10),ar=parseInt(t[5],10),u(i()),console.log("Going to push initial fen: "+r),pr.push(r),!0}/* TODO: this function is pretty much crap - it validates structure but
   * completely ignores content (e.g. doesn't verify that each side has a king)
   * ... we should rewrite this, and ditch the silly error_number field while
   * we're at it
   */
function o(r){var e={0:"No errors.",1:"FEN string must contain six space-delimited fields.",2:"6th field (move number) must be a positive integer.",3:"5th field (half move counter) must be a non-negative integer.",4:"4th field (en-passant square) is invalid.",5:"3rd field (castling availability) is invalid.",6:"2nd field (side to move) is invalid.",7:"1st field (piece positions) does not contain 8 '/'-delimited rows.",8:"1st field (piece positions) is invalid [consecutive numbers].",9:"1st field (piece positions) is invalid [invalid piece].",10:"1st field (piece positions) is invalid [row too large].",11:"Illegal en-passant square"},n=r.split(/\s+/);if(6!==n.length)return{valid:!1,error_number:1,error:e[1]};/* 2nd criterion: move number field is a integer value > 0? */
if(isNaN(n[5])||parseInt(n[5],10)<=0)return{valid:!1,error_number:2,error:e[2]};/* 3rd criterion: half move counter is an integer >= 0? */
if(isNaN(n[4])||parseInt(n[4],10)<0)return{valid:!1,error_number:3,error:e[3]};/* 4th criterion: 4th field is a valid e.p.-string? */
if(!/^(-|[abcdefgh][36])$/.test(n[3]))return{valid:!1,error_number:4,error:e[4]};/* 5th criterion: 3th field is a valid castle-string? */
if(!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(n[2]))return{valid:!1,error_number:5,error:e[5]};/* 6th criterion: 2nd field is "w" (white) or "b" (black)? */
if(!/^(w|b)$/.test(n[1]))return{valid:!1,error_number:6,error:e[6]};/* 7th criterion: 1st field contains 8 rows? */
var t=n[0].split("/");if(8!==t.length)return{valid:!1,error_number:7,error:e[7]};/* 8th criterion: every row is valid? */
for(var o=0;o<t.length;o++){for(var i=0,f=!1,u=0;u<t[o].length;u++)if(isNaN(t[o][u])){if(!/^[prnbqkPRNBQK]$/.test(t[o][u]))return{valid:!1,error_number:9,error:e[9]};i+=1,f=!1}else{if(f)return{valid:!1,error_number:8,error:e[8]};i+=parseInt(t[o][u],10),f=!0}if(8!==i)return{valid:!1,error_number:10,error:e[10]}}return"3"==n[3][1]&&"w"==n[1]||"6"==n[3][1]&&"b"==n[1]?{valid:!1,error_number:11,error:e[11]}:{valid:!0,error_number:0,error:e[0]}}function i(){for(var r=0,e="",n=er.a8;n<=er.h1;n++){if(null==tr[n])r++;else{r>0&&(e+=r,r=0);var t=tr[n].color,o=tr[n].type;e+=t===k?o.toUpperCase():o.toLowerCase()}n+1&136&&(r>0&&(e+=r),n!==er.h1&&(e+="/"),r=0,n+=8)}var i="";fr[k]&J.KSIDE_CASTLE&&(i+="K"),fr[k]&J.QSIDE_CASTLE&&(i+="Q"),fr[O]&J.KSIDE_CASTLE&&(i+="k"),fr[O]&J.QSIDE_CASTLE&&(i+="q"),/* do we have an empty castling flag? */
i=i||"-";var f=ur===q?"-":I(ur);return[e,ir,i,f,lr,ar].join(" ")}function f(r){for(var e=0;e<r.length;e+=2)"string"==typeof r[e]&&"string"==typeof r[e+1]&&(cr[r[e]]=r[e+1]);return cr}/* called when the initial board setup is changed with put() or remove().
   * modifies the SetUp and FEN properties of the header object.  if the FEN is
   * equal to the default position, the SetUp and FEN are deleted
   * the setup is only updated if history.length is zero, ie moves haven't been
   * made.
   */
function u(r){sr.length>0||(r!==B?(cr.SetUp="1",cr.FEN=r):(delete cr.SetUp,delete cr.FEN))}function l(r){var e=tr[er[r]];return e?{type:e.type,color:e.color}:null}function a(r,e){/* check for valid piece object */
if(!("type"in r&&"color"in r))return!1;/* check for piece */
if(-1===j.indexOf(r.type.toLowerCase()))return!1;/* check for valid square */
if(!(e in er))return!1;var n=er[e];/* don't let the user place more than one king */
/* don't let the user place more than one king */
return(r.type!=$||or[r.color]==q||or[r.color]==n)&&(tr[n]={type:r.type,color:r.color},r.type===$&&(or[r.color]=n),u(i()),!0)}function s(r,e,n,t,o){var i={color:ir,from:e,to:n,flags:t,piece:r[e].type};return o&&(i.flags|=J.PROMOTION,i.promotion=o),r[n]?i.captured=r[n].type:t&J.EP_CAPTURE&&(i.captured=D),i}function p(r){function e(r,e,n,t,o){/* if pawn promotion */
if(r[n].type!==D||C(t)!==rr&&C(t)!==V)e.push(s(r,n,t,o));else for(var i=[x,U,Q,K],f=0,u=i.length;f<u;f++)e.push(s(r,n,t,o,i[f]))}var n=[],t=ir,o=P(t),i={b:Y,w:X},f=er.a8,u=er.h1,l=!1,a=!(void 0!==r&&"legal"in r)||r.legal;/* are we generating moves for a single square? */
if(void 0!==r&&"square"in r){if(!(r.square in er))/* invalid square */
return[];f=u=er[r.square],l=!0}for(y=f;y<=u;y++)/* did we run off the end of the board */
if(136&y)y+=7;else{var p=tr[y];if(null!=p&&p.color===t)if(p.type===D){/* single square, non-capturing */
d=y+G[t][0];if(null==tr[d]){e(tr,n,y,d,J.NORMAL);/* double square */
d=y+G[t][1];i[t]===C(y)&&null==tr[d]&&e(tr,n,y,d,J.BIG_PAWN)}/* pawn captures */
for(c=2;c<4;c++){136&(d=y+G[t][c])||(null!=tr[d]&&tr[d].color===o?e(tr,n,y,d,J.CAPTURE):d===ur&&e(tr,n,y,ur,J.EP_CAPTURE))}}else for(var c=0,v=F[p.type].length;c<v;c++)for(var E=F[p.type][c],d=y;;){if(136&(d+=E))break;if(null!=tr[d]){if(tr[d].color===t)break;e(tr,n,y,d,J.CAPTURE);break}/* break, if knight or king */
if(e(tr,n,y,d,J.NORMAL),"n"===p.type||"k"===p.type)break}}/* check for castling if: a) we're generating all moves, or b) we're doing
     * single square move generation on the king's square
     */
if(!l||u===or[t]){/* king-side castling */
if(fr[t]&J.KSIDE_CASTLE){_=(b=or[t])+2;null!=tr[b+1]||null!=tr[_]||g(o,or[t])||g(o,b+1)||g(o,_)||e(tr,n,or[t],_,J.KSIDE_CASTLE)}/* queen-side castling */
if(fr[t]&J.QSIDE_CASTLE){var b=or[t],_=b-2;null!=tr[b-1]||null!=tr[b-2]||null!=tr[b-3]||g(o,or[t])||g(o,b-1)||g(o,_)||e(tr,n,or[t],_,J.QSIDE_CASTLE)}}/* return all pseudo-legal moves (this includes moves that allow the king
     * to be captured)
     */
if(!a)return n;for(var A=[],y=0,v=n.length;y<v;y++)S(n[y]),h(t)||A.push(n[y]),m();return A}/* convert a move from 0x88 coordinates to Standard Algebraic Notation
   * (SAN)
   *
   * @param {boolean} sloppy Use the sloppy SAN generator to work around over
   * disambiguation bugs in Fritz and Chessbase.  See below:
   *
   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4
   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned
   * 4. ... Ne7 is technically the valid SAN
   */
function c(r,e){var n="";if(r.flags&J.KSIDE_CASTLE)n="O-O";else if(r.flags&J.QSIDE_CASTLE)n="O-O-O";else{var t=/* this function is used to uniquely identify ambiguous moves */
function(r,e){for(var n=p({legal:!e}),t=r.from,o=r.to,i=r.piece,f=0,u=0,l=0,a=0,s=n.length;a<s;a++){var c=n[a].from,v=n[a].to,g=n[a].piece;/* if a move of the same piece type ends on the same to square, we'll
       * need to add a disambiguator to the algebraic notation
       */
i===g&&t!==c&&o===v&&(f++,C(t)===C(c)&&u++,T(t)===T(c)&&l++)}if(f>0)/* if there exists a similar moving piece on the same rank and file as
       * the move in question, use the square as the disambiguator
       */
/* if there exists a similar moving piece on the same rank and file as
       * the move in question, use the square as the disambiguator
       */
return u>0&&l>0?I(t):l>0?I(t).charAt(1):I(t).charAt(0);return""}(r,e);r.piece!==D&&(n+=r.piece.toUpperCase()+t),r.flags&(J.CAPTURE|J.EP_CAPTURE)&&(r.piece===D&&(n+=I(r.from)[0]),n+="x"),n+=I(r.to),r.flags&J.PROMOTION&&(n+="="+r.promotion.toUpperCase())}return S(r),E()&&(d()?n+="#":n+="+"),m(),n}
// parses all of the decorators out of a SAN string
function v(r){return r.replace(/=/,"").replace(/[+#]?[?!]*$/,"")}function g(r,e){for(var n=er.a8;n<=er.h1;n++)/* did we run off the end of the board */
if(136&n)n+=7;else/* if empty square or wrong color */
if(null!=tr[n]&&tr[n].color===r){var t=tr[n],o=n-e,i=o+119;if(W[i]&1<<Z[t.type]){if(t.type===D){if(o>0){if(t.color===k)return!0}else if(t.color===O)return!0;continue}/* if the piece is a knight or a king */
if("n"===t.type||"k"===t.type)return!0;for(var f=H[i],u=n+f,l=!1;u!==e;){if(null!=tr[u]){l=!0;break}u+=f}if(!l)return!0}}return!1}function h(r){return g(P(r),or[r])}function E(){return h(ir)}function d(){return E()&&0===p().length}function b(){return!E()&&0===p().length}function _(){for(var r={},e=[],n=0,t=0,o=er.a8;o<=er.h1;o++)if(t=(t+1)%2,136&o)o+=7;else{var i=tr[o];i&&(r[i.type]=i.type in r?r[i.type]+1:1,i.type===Q&&e.push(t),n++)}/* k vs. k */
if(2===n)return!0;if(3===n&&(1===r[Q]||1===r[K]))return!0;if(n===r[Q]+2){for(var f=0,u=e.length,o=0;o<u;o++)f+=e[o];if(0===f||f===u)return!0}return!1}function A(){for(/* TODO: while this function is fine for casual use, a better
     * implementation would use a Zobrist key (instead of FEN). the
     * Zobrist key would be maintained in the make_move/undo_move functions,
     * avoiding the costly that we do below.
     */
var r=[],e={},n=!1;;){var t=m();if(!t)break;r.push(t)}for(;;){/* remove the last two fields in the FEN string, they're not needed
       * when checking for draw by rep */
var o=i().split(" ").slice(0,4).join(" ");if(/* has the position occurred three or move times */
e[o]=o in e?e[o]+1:1,e[o]>=3&&(n=!0),!r.length)break;S(r.pop())}return n}function S(r){var e=ir,n=P(e);/* if we moved the king */
if(function(r){sr.push({move:r,kings:{b:or.b,w:or.w},turn:ir,castling:{b:fr.b,w:fr.w},ep_square:ur,half_moves:lr,move_number:ar})}(r),tr[r.to]=tr[r.from],tr[r.from]=null,/* if ep capture, remove the captured pawn */
r.flags&J.EP_CAPTURE&&(ir===O?tr[r.to-16]=null:tr[r.to+16]=null),/* if pawn promotion, replace with new piece */
r.flags&J.PROMOTION&&(tr[r.to]={type:r.promotion,color:e}),tr[r.to].type===$){/* if we castled, move the rook next to the king */
if(or[tr[r.to].color]=r.to,r.flags&J.KSIDE_CASTLE){var t=r.to-1,o=r.to+1;tr[t]=tr[o],tr[o]=null}else if(r.flags&J.QSIDE_CASTLE){var t=r.to+1,o=r.to-2;tr[t]=tr[o],tr[o]=null}/* turn off castling */
fr[e]=""}/* turn off castling if we move a rook */
if(fr[e])for(var f=0,u=nr[e].length;f<u;f++)if(r.from===nr[e][f].square&&fr[e]&nr[e][f].flag){fr[e]^=nr[e][f].flag;break}/* turn off castling if we capture a rook */
if(fr[n])for(var f=0,u=nr[n].length;f<u;f++)if(r.to===nr[n][f].square&&fr[n]&nr[n][f].flag){fr[n]^=nr[n][f].flag;break}/* if big pawn move, update the en passant square */
ur=r.flags&J.BIG_PAWN?"b"===ir?r.to-16:r.to+16:q,/* reset the 50 move counter if a pawn is moved or a piece is captured */
r.piece===D?lr=0:r.flags&(J.CAPTURE|J.EP_CAPTURE)?lr=0:lr++,ir===O&&ar++,ir=P(ir),pr.push(i())}function m(){var r=sr.pop();pr.length<=1||pr.pop();//Added in sandy98 fork. Don't erase fen if it is the first one.
if(null==r)return null;var e=r.move;or=r.kings,ir=r.turn,fr=r.castling,ur=r.ep_square,lr=r.half_moves,ar=r.move_number;var n=ir,t=P(ir);if(tr[e.from]=tr[e.to],tr[e.from].type=e.piece,// to undo any promotions
tr[e.to]=null,e.flags&J.CAPTURE)tr[e.to]={type:e.captured,color:t};else if(e.flags&J.EP_CAPTURE){var o;o=n===O?e.to-16:e.to+16,tr[o]={type:D,color:t}}if(e.flags&(J.KSIDE_CASTLE|J.QSIDE_CASTLE)){var i,f;e.flags&J.KSIDE_CASTLE?(i=e.to+1,f=e.to-1):e.flags&J.QSIDE_CASTLE&&(i=e.to-2,f=e.to+1),tr[i]=tr[f],tr[f]=null}return e}
// convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates
function y(r,e){
// strip off any move decorations: e.g Nf3+?!
var n=v(r);
// if we're using the sloppy parser run a regex to grab piece, to, and from
// this should parse invalid SAN like: Pe2-e4, Rc1c4, Qf3xf7
if(e){var t=n.match(/([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/);if(t)var o=t[1],i=t[2],f=t[3],u=t[4]}for(var l=p(),a=0,s=l.length;a<s;a++){
// try the strict parser first, then the sloppy parser if requested
// by the user
if(n===v(c(l[a]))||e&&n===v(c(l[a],!0)))return l[a];if(t&&(!o||o.toLowerCase()==l[a].piece)&&er[i]==l[a].from&&er[f]==l[a].to&&(!u||u.toLowerCase()==l[a].promotion))return l[a]}return null}/*****************************************************************************
   * UTILITY FUNCTIONS
   ****************************************************************************/
function C(r){return r>>4}function T(r){return 15&r}function I(r){var e=T(r),n=C(r);return"abcdefgh".substring(e,e+1)+"87654321".substring(n,n+1)}function P(r){return r===k?O:k}/* pretty = external move object */
function w(r){var e=L(r);e.san=c(e,!1),e.to=I(e.to),e.from=I(e.from);var n="";for(var t in J)J[t]&e.flags&&(n+=z[t]);return e.flags=n,e}function L(r){var e=r instanceof Array?[]:{};for(var n in r)e[n]="object"==typeof n?L(r[n]):r[n];return e}function R(r){return r.replace(/^\s+|\s+$/g,"")}/*****************************************************************************
   * DEBUGGING UTILITIES
   ****************************************************************************/
function N(r){for(var e=p({legal:!1}),n=0,t=ir,o=0,i=e.length;o<i;o++){if(S(e[o]),!h(t))if(r-1>0){n+=N(r-1)}else n++;m()}return n}/* jshint indent: false */
var O="b",k="w",q=-1,D="p",K="n",Q="b",U="r",x="q",$="k",j="pnbrqkPNBRQK",B="rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1",M=["1-0","0-1","1/2-1/2","*"],G={b:[16,32,17,15],w:[-16,-32,-17,-15]},F={n:[-18,-33,-31,-14,18,33,31,14],b:[-17,-15,17,15],r:[-16,1,16,-1],q:[-17,-16,-15,1,17,16,15,-1],k:[-17,-16,-15,1,17,16,15,-1]},W=[20,0,0,0,0,0,0,24,0,0,0,0,0,0,20,0,0,20,0,0,0,0,0,24,0,0,0,0,0,20,0,0,0,0,20,0,0,0,0,24,0,0,0,0,20,0,0,0,0,0,0,20,0,0,0,24,0,0,0,20,0,0,0,0,0,0,0,0,20,0,0,24,0,0,20,0,0,0,0,0,0,0,0,0,0,20,2,24,2,20,0,0,0,0,0,0,0,0,0,0,0,2,53,56,53,2,0,0,0,0,0,0,24,24,24,24,24,24,56,0,56,24,24,24,24,24,24,0,0,0,0,0,0,2,53,56,53,2,0,0,0,0,0,0,0,0,0,0,0,20,2,24,2,20,0,0,0,0,0,0,0,0,0,0,20,0,0,24,0,0,20,0,0,0,0,0,0,0,0,20,0,0,0,24,0,0,0,20,0,0,0,0,0,0,20,0,0,0,0,24,0,0,0,0,20,0,0,0,0,20,0,0,0,0,0,24,0,0,0,0,0,20,0,0,20,0,0,0,0,0,0,24,0,0,0,0,0,0,20],H=[17,0,0,0,0,0,0,16,0,0,0,0,0,0,15,0,0,17,0,0,0,0,0,16,0,0,0,0,0,15,0,0,0,0,17,0,0,0,0,16,0,0,0,0,15,0,0,0,0,0,0,17,0,0,0,16,0,0,0,15,0,0,0,0,0,0,0,0,17,0,0,16,0,0,15,0,0,0,0,0,0,0,0,0,0,17,0,16,0,15,0,0,0,0,0,0,0,0,0,0,0,0,17,16,15,0,0,0,0,0,0,0,1,1,1,1,1,1,1,0,-1,-1,-1,-1,-1,-1,-1,0,0,0,0,0,0,0,-15,-16,-17,0,0,0,0,0,0,0,0,0,0,0,0,-15,0,-16,0,-17,0,0,0,0,0,0,0,0,0,0,-15,0,0,-16,0,0,-17,0,0,0,0,0,0,0,0,-15,0,0,0,-16,0,0,0,-17,0,0,0,0,0,0,-15,0,0,0,0,-16,0,0,0,0,-17,0,0,0,0,-15,0,0,0,0,0,-16,0,0,0,0,0,-17,0,0,-15,0,0,0,0,0,0,-16,0,0,0,0,0,0,-17],Z={p:0,n:1,b:2,r:3,q:4,k:5},z={NORMAL:"n",CAPTURE:"c",BIG_PAWN:"b",EP_CAPTURE:"e",PROMOTION:"p",KSIDE_CASTLE:"k",QSIDE_CASTLE:"q"},J={NORMAL:1,CAPTURE:2,BIG_PAWN:4,EP_CAPTURE:8,PROMOTION:16,KSIDE_CASTLE:32,QSIDE_CASTLE:64},V=7,X=6,Y=1,rr=0,er={a8:0,b8:1,c8:2,d8:3,e8:4,f8:5,g8:6,h8:7,a7:16,b7:17,c7:18,d7:19,e7:20,f7:21,g7:22,h7:23,a6:32,b6:33,c6:34,d6:35,e6:36,f6:37,g6:38,h6:39,a5:48,b5:49,c5:50,d5:51,e5:52,f5:53,g5:54,h5:55,a4:64,b4:65,c4:66,d4:67,e4:68,f4:69,g4:70,h4:71,a3:80,b3:81,c3:82,d3:83,e3:84,f3:85,g3:86,h3:87,a2:96,b2:97,c2:98,d2:99,e2:100,f2:101,g2:102,h2:103,a1:112,b1:113,c1:114,d1:115,e1:116,f1:117,g1:118,h1:119},nr={w:[{square:er.a1,flag:J.QSIDE_CASTLE},{square:er.h1,flag:J.KSIDE_CASTLE}],b:[{square:er.a8,flag:J.QSIDE_CASTLE},{square:er.h8,flag:J.KSIDE_CASTLE}]},tr=new Array(128),or={w:q,b:q},ir=k,fr={w:0,b:0},ur=q,lr=0,ar=1,sr=[],pr=[],cr={};/* if the user passes in a fen string, load it, else default to
   * starting position
   */
return t(void 0===r?B:r),{/***************************************************************************
     * PUBLIC CONSTANTS (is there a better way to do this?)
     **************************************************************************/
WHITE:k,BLACK:O,PAWN:D,KNIGHT:K,BISHOP:Q,ROOK:U,QUEEN:x,KING:$,SQUARES:function(){for(var r=[],e=er.a8;e<=er.h1;e++)136&e?e+=7:r.push(I(e));return r}(),FLAGS:z,/***************************************************************************
     * PUBLIC API
     **************************************************************************/
load:function(r){return t(r)},reset:function(){return n()},moves:function(r){for(var e=p(r),n=[],t=0,o=e.length;t<o;t++)/* does the user want a full move object (most likely not), or just
         * SAN
         */
void 0!==r&&"verbose"in r&&r.verbose?n.push(w(e[t])):n.push(c(e[t],!1));return n},in_check:function(){return E()},in_checkmate:function(){return d()},in_stalemate:function(){return b()},in_draw:function(){return lr>=100||b()||_()||A()},insufficient_material:function(){return _()},in_threefold_repetition:function(){return A()},game_over:function(){return lr>=100||d()||b()||_()||A()},validate_fen:function(r){return o(r)},fen:function(){return i()},board:function(){for(var r=[],e=[],n=er.a8;n<=er.h1;n++)null==tr[n]?e.push(null):e.push({type:tr[n].type,color:tr[n].color}),n+1&136&&(r.push(e),e=[],n+=8);return r},pgn:function(r){/* using the specification from http://www.chessclub.com/help/PGN-spec
       * example for html usage: .pgn({ max_width: 72, newline_char: "<br />" })
       */
var e="object"==typeof r&&"string"==typeof r.newline_char?r.newline_char:"\n",n="object"==typeof r&&"number"==typeof r.max_width?r.max_width:0,t=[],o=!1;/* add the PGN header headerrmation */
for(var i in cr)/* TODO: order of enumerated properties in header object is not
         * guaranteed, see ECMA-262 spec (section 12.6.4)
         */
t.push("["+i+' "'+cr[i]+'"]'+e),o=!0;o&&sr.length&&t.push(e);for(/* pop all of history onto reversed_history */
var f=[];sr.length>0;)f.push(m());/* build the list of moves.  a move_string looks like: "3. e3 e6" */
for(var u=[],l="";f.length>0;){var a=f.pop();/* if the position started with black to move, start PGN with 1. ... */
sr.length||"b"!==a.color?"w"===a.color&&(/* store the previous generated move_string if we have one */
l.length&&u.push(l),l=ar+"."):l=ar+". ...",l=l+" "+c(a,!1),S(a)}/* history should be back to what is was before we started generating PGN,
       * so join together moves
       */
if(/* are there any other leftover moves? */
l.length&&u.push(l),/* is there a result? */
void 0!==cr.Result&&u.push(cr.Result),0===n)return t.join("")+u.join(" ");for(var s=0,i=0;i<u.length;i++)/* if the current move will push past max_width */
s+u[i].length>n&&0!==i?(/* don't end the line with whitespace */
" "===t[t.length-1]&&t.pop(),t.push(e),s=0):0!==i&&(t.push(" "),s++),t.push(u[i]),s+=u[i].length;return t.join("")},load_pgn:function(r,e){function o(r){return r.replace(/\\/g,"\\")}
// allow the user to specify the sloppy move parser to work around over
// disambiguation bugs in Fritz and Chessbase
var i=void 0!==e&&"sloppy"in e&&e.sloppy,u="object"==typeof e&&"string"==typeof e.newline_char?e.newline_char:"\r?\n",l=new RegExp("^(\\[(.|"+o(u)+")*\\])("+o(u)+")*1.("+o(u)+"|.)*$","g"),a=r.replace(l,"$1");/* no info part given, begins with moves */
"["!==a[0]&&(a=""),n();/* parse PGN header */
var s=function(r,e){for(var n="object"==typeof e&&"string"==typeof e.newline_char?e.newline_char:"\r?\n",t={},i=r.split(new RegExp(o(n))),f="",u="",l=0;l<i.length;l++)f=i[l].replace(/^\[([A-Z][A-Za-z]*)\s.*\]$/,"$1"),u=i[l].replace(/^\[[A-Za-z]+\s"(.*)"\]$/,"$1"),R(f).length>0&&(t[f]=u);return t}(a,e);for(var p in s)f([p,s[p]]);/* load the starting position indicated by [Setup '1'] and
      * [FEN position] */
if("1"===s.SetUp&&!("FEN"in s&&t(s.FEN,!0)))// second argument to load: don't clear the headers
return!1;/* delete header to get the moves */
var c=r.replace(a,"").replace(new RegExp(o(u),"g")," ");/* delete comments */
c=c.replace(/(\{[^}]+\})+?/g,"");for(/* delete recursive annotation variations */
var v=/(\([^\(\)]+\))+?/g;v.test(c);)c=c.replace(v,"");/* trim and get array of moves */
var g=R(/* delete numeric annotation glyphs */
c=(/* delete ... indicating black to move */
c=(/* delete move numbers */
c=c.replace(/\d+\.(\.\.)?/g,"")).replace(/\.\.\./g,"")).replace(/\$\d+/g,"")).split(new RegExp(/\s+/));/* delete empty entries */
g=g.join(",").replace(/,,+/g,",").split(",");for(var h="",E=0;E<g.length-1;E++){/* move not possible! (don't clear the board to examine to show the
         * latest valid position)
         */
if(null==(h=y(g[E],i)))return!1;S(h)}if(/* examine last move */
h=g[g.length-1],M.indexOf(h)>-1)(function(r){for(var e in r)return!0;return!1})(cr)&&void 0===cr.Result&&f(["Result",h]);else{if(null==(h=y(h,i)))return!1;S(h)}return!0},header:function(){return f(arguments)},ascii:function(){return function(){for(var r="   +------------------------+\n",e=er.a8;e<=er.h1;e++){/* empty piece */
if(/* display the rank */
0===T(e)&&(r+=" "+"87654321"[C(e)]+" |"),null==tr[e])r+=" . ";else{var n=tr[e].type;r+=" "+(tr[e].color===k?n.toUpperCase():n.toLowerCase())+" "}e+1&136&&(r+="|\n",e+=8)}return r+="   +------------------------+\n",r+="     a  b  c  d  e  f  g  h\n"}()},turn:function(){return ir},move:function(r,e){/* The move function can be called with in the following parameters:
       *
       * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string
       *
       * .move({ from: 'h7', <- where the 'move' is a move object (additional
       *         to :'h8',      fields are ignored)
       *         promotion: 'q',
       *      })
       */
// allow the user to specify the sloppy move parser to work around over
// disambiguation bugs in Fritz and Chessbase
var n=void 0!==e&&"sloppy"in e&&e.sloppy,t=null;if("string"==typeof r)t=y(r,n);else if("object"==typeof r)/* convert the pretty move object to an ugly move object */
for(var o=p(),i=0,f=o.length;i<f;i++)if(!(r.from!==I(o[i].from)||r.to!==I(o[i].to)||"promotion"in o[i]&&r.promotion!==o[i].promotion)){t=o[i];break}/* failed to find move */
if(!t)return null;/* need to make a copy of move because we can't generate SAN after the
       * move is made
       */
var u=w(t);return S(t),u},undo:function(){var r=m();return r?w(r):null},clear:function(){return e()},put:function(r,e){return a(r,e)},get:function(r){return l(r)},remove:function(r){return function(r){var e=l(r);return tr[er[r]]=null,e&&e.type===$&&(or[e.color]=q),u(i()),e}(r)},perft:function(r){return N(r)},square_color:function(r){if(r in er){var e=er[r];return(C(e)+T(e))%2==0?"light":"dark"}return null},
//Added in sandy98 fork. Function fens, exposes internal fens (positions) array. To be used by board components/widgets which deal with positions. 
fens:function(){return pr},history:function(r){for(var e=[],n=[],t=(void 0!==r&&"verbose"in r&&r.verbose);sr.length>0;)e.push(m());for(;e.length>0;){var o=e.pop();t?n.push(w(o)):n.push(c(o)),S(o)}return n}}};/* export Chess object if using node or any other CommonJS compatible
 * environment */
"undefined"!=typeof exports&&(exports.Chess=Chess),/* export Chess object for any RequireJS compatible environment */
"undefined"!=typeof define&&define(function(){return Chess});
